esp32:
  board: esp32dev
  framework:
    type: arduino

psram:

wifi:
  power_save_mode: none

api:
  services:
    # - service: set_display_page
    #   variables:
    #     page: int
    #   then:
    #     - lambda: 'esp32_thermostat::set_display_page(page);'
    - service: update_nextion
      then:
        - lambda: "main_lcd->upload_tft();"
    - service: update_status
      variables:
        message: string
      then:
        - globals.set:
            id: status_string
            value: !lambda "return message;"
        - script.execute: refresh_display_status_string

globals:
  # the temperature/humidity that guides the thermostat controller
  - id: current_humidity
    type: float
    restore_value: yes
    initial_value: "0"
  - id: current_temperature
    type: float
    restore_value: yes
    initial_value: "-100"
  # last hour display was fully refreshed
  - id: display_last_full_refresh
    type: int
    restore_value: no
    initial_value: "-1"
  # number of sensor updates while offline
  - id: missed_update_count
    type: int
    restore_value: no
    initial_value: "0"
  # row on which local sensor data is placed in the climate data table
  - id: climate_table_local_row
    type: int
    restore_value: no
    initial_value: "-1"
  # status string
  - id: status_string
    type: std::string
    restore_value: no
    initial_value: '""'
  # weather condition, temperature, humidity
  - id: weather_air_quality
    type: float
    restore_value: yes
    initial_value: "0"
  - id: weather_condition
    type: std::string
    restore_value: no
    initial_value: '""'
  - id: weather_humidity
    type: float
    restore_value: yes
    initial_value: "0"
  - id: weather_temperature
    type: float
    restore_value: yes
    initial_value: "-100"
  - id: weather_temperature_high
    type: float
    restore_value: no
    initial_value: "-100"
  - id: weather_temperature_low
    type: float
    restore_value: no
    initial_value: "-100"
  # flag to indicate template sensor is ready
  - id: sensor_ready
    type: bool
    restore_value: no
    initial_value: "false"

script:
  # display power management
  - id: motion_sense
    mode: restart
    then:
      - lambda: "id(nextionIdleTimer).set_state(0, true, true);"
  # update climate action on display
  - id: refresh_display_climate_action
    mode: restart
    then:
      - lambda: |-
          id(nextionClimateAction).set_state(static_cast<float>(id(esp_thermostat).action), false, true);
      - script.execute: refresh_display_lockout_state
  # update climate mode on display
  - id: refresh_display_climate_mode
    mode: restart
    then:
      - lambda: |-
          id(nextionClimateMode).set_state(static_cast<float>(id(esp_thermostat).mode), false, true);
      - script.execute: refresh_display_climate_action
  # update fan mode on display
  - id: refresh_display_climate_fan_mode
    mode: restart
    then:
      - lambda: |-
          id(nextionClimateFanMode).set_state(static_cast<float>(id(esp_thermostat).fan_mode.value_or(CLIMATE_FAN_AUTO)), false, true);
      - script.execute: refresh_display_lockout_state
  # update lockout state on display
  - id: refresh_display_lockout_state
    mode: restart
    then:
      - lambda: |-
          float lockout = (id(esp_thermostat).climate_action_change_delayed() || id(esp_thermostat).fan_mode_change_delayed()) ? 1 : 0;
          id(nextionLockoutState).set_state(lockout, false, true);
  # update set points on display
  - id: refresh_display_set_points
    mode: restart
    then:
      - lambda: |-
          id(nextionCurrentSetLower).set_state(roundf((celsius_to_fahrenheit(id(esp_thermostat).target_temperature_low)) * 10), false, true);
          id(nextionCurrentSetUpper).set_state(roundf((celsius_to_fahrenheit(id(esp_thermostat).target_temperature_high)) * 10), false, true);
          id(nextionCurrentSetHum).set_state(id(esp_thermostat_target_humidity).state * 10, false, true);
          if (id(nextionCurrentSetMin).state != (celsius_to_fahrenheit(id(esp_thermostat).get_traits().get_visual_min_temperature())) * 10) {
            id(nextionCurrentSetMin).set_state((celsius_to_fahrenheit(id(esp_thermostat).get_traits().get_visual_min_temperature())) * 10, true, true);
          }
          if (id(nextionCurrentSetMax).state != (celsius_to_fahrenheit(id(esp_thermostat).get_traits().get_visual_max_temperature())) * 10) {
            id(nextionCurrentSetMax).set_state((celsius_to_fahrenheit(id(esp_thermostat).get_traits().get_visual_max_temperature())) * 10, true, true);
          }
  # update status string on display
  - id: refresh_display_status_string
    mode: restart
    then:
      - lambda: |-
          const std::string offline_message = "offline";
          std::string status_message;

          if (id(esp_thermostat_api_status).state == false) {
            status_message = offline_message;
          }

          if (status_message.empty()) {
            status_message = id(status_string);
          } else if (!id(status_string).empty()) {
            status_message = status_message + " - " + id(status_string);
          }

          if (!status_message.empty()) {
            status_message[0] = toupper(status_message[0]);
          }

          if (id(nextionTextStatus).state != status_message) {
            id(nextionTextStatus).set_state(status_message, false, true);
          }
  # update AQI/IAQ on display
  - id: refresh_display_iaq
    mode: restart
    parameters:
      iaq_value: float
      is_weather: bool
    then:
      - lambda: |-
          struct IaqCondPairing {
            const uint16_t threshold;
            const Color color;
            const std::string condition;
          };

          static const std::vector<IaqCondPairing> iaq_cond_text{
              {50, Color(0, 255, 96), "Excellent"},        {100, Color(160, 255, 0), "Good"},
              {150, Color(255, 255, 0), "Moderate"},       {200, Color(255, 127, 0), "Unhealthy"},
              {300, Color(255, 32, 32), "Very Unhealthy"}, {9000, Color(160, 24, 64), "Hazardous"}};

          auto iaq_string = str_sprintf("%.1f", iaq_value);
          auto iaq_color = Color::WHITE;

          for (IaqCondPairing i : iaq_cond_text) {
            if (iaq_value < i.threshold) {
              iaq_string += " - " + i.condition;
              iaq_color = i.color;
              break;
            }
          }

          if (is_weather) {
            id(nextionTextWeatherAq).set_state(iaq_string, false, true);
            id(nextionTextWeatherAq).set_foreground_color(iaq_color);
          } else {
            id(nextionTextCurrentAq).set_state(iaq_string, false, true);
            id(nextionTextCurrentAq).set_foreground_color(iaq_color);
          }
  # update weather condition on display
  - id: refresh_display_weather_condition
    mode: restart
    then:
      - lambda: |-
          struct WeatherCondPairing {
            const char icon_id;
            const std::string condition;
          };

          static const std::vector<WeatherCondPairing> weather_cond_icon{
              {'F', "clear-night"}, {'A', "cloudy"},          {'O', "exceptional"},  {'B', "fog"},     {'C', "hail"},
              {'E', "lightning"},   {'D', "lightning-rainy"}, {'G', "partlycloudy"}, {'H', "pouring"}, {'I', "rainy"},
              {'K', "snowy"},       {'J', "snowy-rainy"},     {'L', "sunny"},        {'M', "windy"},   {'N', "windy-variant"}};

          const char default_weather_cond_icon_id = 'O';
          std::string icon_id(1, default_weather_cond_icon_id);

          for (WeatherCondPairing i : weather_cond_icon) {
            if (i.condition == id(weather_condition)) {
              icon_id[0] = i.icon_id;
              break;
            }
          }
          id(nextionTextWeatherIcon).set_state(icon_id, false, true);

          auto capitalized_weather_condition = id(weather_condition);
          if (capitalized_weather_condition == "partlycloudy")
            capitalized_weather_condition = "partly cloudy";
          if (capitalized_weather_condition == "sunny")
            capitalized_weather_condition = "clear";

          capitalized_weather_condition.append(":");
          capitalized_weather_condition[0] = toupper(capitalized_weather_condition[0]);
          id(nextionTextRoom7).set_state(capitalized_weather_condition, false, true);

status_led:
  pin:
    number: 5
    inverted: true

time:
  - platform: homeassistant
    id: esptime
    timezone: CST+6CDT,M3.2.0/2,M11.1.0/2

i2c:
  id: i2c_bus
  frequency: 400kHz
  sda: 21
  scl: 22
  scan: false

# spi:
#   clk_pin: 14
#   mosi_pin: 13
#   miso_pin: 12

uart:
  id: nextion_uart
  tx_pin: 19
  rx_pin: 18
  baud_rate: 921600

climate:
  - platform: thermostat
    id: esp_thermostat
    name: none
    sensor: esp_thermostat_temperature_sensor
    startup_delay: true
    supplemental_cooling_delta: 4°F
    cool_deadband: 1°F
    cool_overrun: 1°F
    min_cooling_off_time: 300s
    min_cooling_run_time: 300s
    max_cooling_run_time: 1800s
    supplemental_heating_delta: 4°F
    heat_deadband: 1°F
    heat_overrun: 1°F
    min_heating_off_time: 300s
    min_heating_run_time: 300s
    max_heating_run_time: 1800s
    min_fan_mode_switching_time: 30s
    # min_fanning_off_time: 30s
    # min_fanning_run_time: 30s
    min_idle_time: 30s
    set_point_minimum_differential: 1°F
    fan_only_action_uses_fan_mode_timer: true
    fan_only_cooling: true
    fan_with_cooling: true
    # fan_with_heating: true
    visual:
      min_temperature: 60°F
      max_temperature: 90°F
      temperature_step: 0.1
    on_boot_restore_from: memory
    default_preset: home
    preset:
      - name: "away"
        default_target_temperature_low: 68°F
        default_target_temperature_high: 78°F
      - name: "boost"
        default_target_temperature_low: 74°F
        default_target_temperature_high: 76°F
      - name: "comfort"
        default_target_temperature_low: 70°F
        default_target_temperature_high: 72°F
      - name: "eco"
        default_target_temperature_low: 72°F
        default_target_temperature_high: 76°F
      - name: "home"
        default_target_temperature_low: 73°F
        default_target_temperature_high: 75°F
    off_mode:
      - lambda: "id(esp_thermostat).fan_mode = climate::CLIMATE_FAN_AUTO;"
      - script.execute: refresh_display_climate_mode
      - script.execute: refresh_display_climate_fan_mode
    auto_mode:
      - script.execute: refresh_display_climate_mode
    cool_mode:
      - script.execute: refresh_display_climate_mode
    heat_mode:
      - script.execute: refresh_display_climate_mode
    fan_only_mode:
      - script.execute: refresh_display_climate_mode
    cool_action:
      - switch.turn_off: esp_thermostat_heat_2
      - switch.turn_off: esp_thermostat_heat_1
      - switch.turn_on: esp_thermostat_cool_1
      - delay: 250ms
      - script.execute: refresh_display_climate_action
    supplemental_cooling_action:
      - switch.turn_on: esp_thermostat_cool_2
      - delay: 250ms
      - script.execute: refresh_display_climate_action
    heat_action:
      - switch.turn_off: esp_thermostat_cool_2
      - switch.turn_off: esp_thermostat_cool_1
      - switch.turn_on: esp_thermostat_heat_1
      - delay: 250ms
      - script.execute: refresh_display_climate_action
    supplemental_heating_action:
      - switch.turn_on: esp_thermostat_heat_2
      - delay: 250ms
      - script.execute: refresh_display_climate_action
    idle_action:
      - switch.turn_off: esp_thermostat_cool_2
      - switch.turn_off: esp_thermostat_cool_1
      - switch.turn_off: esp_thermostat_heat_2
      - switch.turn_off: esp_thermostat_heat_1
      - switch.turn_off: esp_thermostat_humidify
      - lambda: |-
          if (id(esp_thermostat).fan_mode == climate::CLIMATE_FAN_AUTO)
            id(esp_thermostat_fan).turn_off();
      - delay: 250ms
      - script.execute: refresh_display_climate_action
    fan_only_action:
      - switch.turn_on: esp_thermostat_fan
      - delay: 250ms
      - script.execute: refresh_display_climate_action
    fan_mode_auto_action:
      - lambda: |-
          if ((id(esp_thermostat).action != climate::CLIMATE_ACTION_COOLING)
           && (id(esp_thermostat).action != climate::CLIMATE_ACTION_FAN))
            id(esp_thermostat_fan).turn_off();
      - delay: 250ms
      - script.execute: refresh_display_climate_fan_mode
    fan_mode_on_action:
      - switch.turn_on: esp_thermostat_fan
      - delay: 250ms
      - script.execute: refresh_display_climate_fan_mode
    target_temperature_change_action:
      - script.execute: refresh_display_set_points
      - delay: 250ms
      - script.execute: refresh_display_climate_action

binary_sensor:
  - platform: status
    id: esp_thermostat_api_status
    name: API Status
    on_state:
      then:
        - script.execute: refresh_display_status_string
  # flag to indicate when the on-board sensor is in use
  - platform: template
    id: esp_thermostat_on_board_sensor_active
    name: On-board Sensor Active
    # if the API is connected, use the max_missed_online_updates as the max, else use max_missed_offline_updates
    lambda: |-
      const uint8_t max_missed_online_updates = 60 * (60 / 15);
      const uint8_t max_missed_offline_updates = 5 * (60 / 15);
      const uint32_t max_missed_updates = id(esp_thermostat_api_status).state ? max_missed_online_updates : max_missed_offline_updates;
      return id(missed_update_count) > max_missed_updates;
  # - platform: gpio
  #   id: esp_thermostat_tmp117_alert
  #   name: TMP117 Alert
  #   pin:
  #     mcp23017: mcp23017_hub
  #     number: 15
  #     mode: INPUT_PULLUP
  # - platform: gpio
  #   id: esp_thermostat_mcp23017_int_a
  #   name: MCP23017 Interrupt A
  #   pin:
  #     number: 36
  # - platform: gpio
  #   id: esp_thermostat_mcp23017_int_b
  #   name: MCP23017 Interrupt B
  #   pin:
  #     number: 39
  - platform: gpio
    id: esp_thermostat_motion_detection
    name: Motion Detection
    device_class: motion
    pin:
      number: 27
    on_state:
      then:
        - if:
            condition:
              switch.is_on: esp_thermostat_display_on_motion
            then:
              - script.execute: motion_sense
  - platform: gpio
    id: esp_thermostat_mode_button
    name: Mode Button
    pin:
      number: 0
      inverted: true
    on_click:
      min_length: 50ms
      max_length: 500ms
      then:
        - script.execute: motion_sense
        - climate.control:
            id: esp_thermostat
            mode: "off"
            fan_mode: "auto"

sensor:
  # template sensor used for thermostat component
  - platform: template
    id: esp_thermostat_temperature_sensor
    name: Template Temperature Sensor
    unit_of_measurement: "°C"
    lambda: |-
      bool template_sensor_valid =
          (id(current_temperature) >= id(esp_thermostat).get_traits().get_visual_min_temperature()) &&
          (id(current_temperature) <= id(esp_thermostat).get_traits().get_visual_max_temperature());
      float sensor_value = id(esp_thermostat_bme680_temperature).state;
      // always increment the counter -- it'll get reset later if appropriate
      id(missed_update_count) += 1;
      // update the display to refresh the status as appropriate
      id(refresh_display_status_string)->execute();
      // measure the thermistor (kind of arbitrary but we do it here)
      id(esp_thermostat_thermistor_vcc).turn_on();
      id(adc_sensor_thermistor).update();
      // id(esp_thermostat_thermistor_vcc).turn_off();
      // update the display to refresh the lockout status as appropriate
      id(refresh_display_lockout_state)->execute();
      // determine what value to return for the sensor
      // if the on-board sensor is flagged as active or if the template sensor's value (aka current_temperature)
      //  is not valid, we must (try to) use the on-board hardware sensor
      if (id(esp_thermostat_on_board_sensor_active).state || !template_sensor_valid) {
        // if the hardware sensor is "ready" (not NaN), we use that value
        if (!isnan(sensor_value)) {
          id(sensor_ready) = true;
          id(current_temperature) = sensor_value;
          return sensor_value;
        } else {
          // if the hardware sensor is NOT "ready" (not NaN), we return a (fake) neutral value.
          // not ideal but this should be only very rarely used
          return (id(esp_thermostat).target_temperature_low + id(esp_thermostat).target_temperature_high) / 2;
        }
      } else {
        // if the on-board sensor is NOT flagged as active and the template sensor's value (aka current_temperature)
        //  is valid, we return that value
        id(sensor_ready) = true;
        return id(current_temperature);
      }
    update_interval: 15s
    on_value:
      then:
        - lambda: "id(nextionCurrentTemp).set_state(roundf(celsius_to_fahrenheit(id(esp_thermostat_temperature_sensor).state) * 10), false, true);"
  # template sensor used for humidity
  - platform: template
    id: esp_thermostat_humidity_sensor
    name: Template Humidity Sensor
    unit_of_measurement: "%"
    lambda: |-
      bool template_sensor_valid = id(current_humidity) > 0;
      float sensor_value = id(esp_thermostat_bme680_humidity).state;
      // determine what value to return for the sensor
      // if the on-board sensor is flagged as active or if the template sensor's value (aka current_humidity)
      //  is not valid, we must (try to) use the on-board hardware sensor
      if (id(esp_thermostat_on_board_sensor_active).state || !template_sensor_valid) {
        // if the hardware sensor is "ready" (not NaN), we use that value
        if (!isnan(sensor_value)) {
          id(sensor_ready) = true;
          id(current_humidity) = sensor_value;
        } else {
          // if the hardware sensor is NOT "ready" (not NaN), we return a (fake) neutral value.
          // not ideal but this should be only very rarely used
          sensor_value = id(esp_thermostat_target_humidity).state;
        }
      } else {
        // if the on-board sensor is NOT flagged as active and the template sensor's value (aka current_humidity)
        //  is valid, we return that value
        id(sensor_ready) = true;
        sensor_value = id(current_humidity);
      }
      // switch humidifier on/off as required
      if ((sensor_value >= id(esp_thermostat_target_humidity).state + 1) ||
          (id(esp_thermostat).action != CLIMATE_ACTION_HEATING)) {
        id(esp_thermostat_humidify).turn_off();
      } else if (sensor_value <= id(esp_thermostat_target_humidity).state - 1) {
        id(esp_thermostat_humidify).turn_on();
      }

      return sensor_value;
    update_interval: 15s
    on_value:
      then:
        - lambda: "id(nextionCurrentHum).set_state(roundf(id(esp_thermostat_humidity_sensor).state * 10), false, true);"
  # HA sensors we track - humidity
  - platform: homeassistant
    id: system_humidity_ha
    entity_id: sensor.thermostat_system_humidity
    on_value:
      then:
        - globals.set:
            id: current_humidity
            value: !lambda "return x;"
        - if:
            condition:
              lambda: "return x != id(esp_thermostat_humidity_sensor).state;"
            then:
              - globals.set:
                  id: missed_update_count
                  value: "0"
        # - lambda: "id(nextionCurrentHum).set_state(roundf(x * 10), false, true);"
  # HA sensors we track - temperature
  - platform: homeassistant
    id: system_temperature_ha
    entity_id: sensor.thermostat_system_temperature
    on_value:
      then:
        - globals.set:
            id: current_temperature
            value: !lambda "return fahrenheit_to_celsius(x);"
        - if:
            condition:
              lambda: "return x != id(esp_thermostat_temperature_sensor).state;"
            then:
              - globals.set:
                  id: missed_update_count
                  value: "0"
        # - lambda: "id(nextionCurrentTemp).set_state(roundf(x * 10), false, true);"
  - platform: homeassistant
    id: system_temperature_maximum_over_last_24_hours_ha
    entity_id: sensor.thermostat_system_temperature_maximum_over_last_24_hours
    on_value:
      then:
        - lambda: "id(nextionCurrentTempHigh).set_state(roundf(x * 10), false, true);"
  - platform: homeassistant
    id: system_temperature_minimum_over_last_24_hours_ha
    entity_id: sensor.thermostat_system_temperature_minimum_over_last_24_hours
    on_value:
      then:
        - lambda: "id(nextionCurrentTempLow).set_state(roundf(x * 10), false, true);"
  # HA sensors we track - weather
  - platform: homeassistant
    id: weather_air_quality_ha
    entity_id: ${air_quality_entity}
    on_value:
      then:
        - globals.set:
            id: weather_air_quality
            value: !lambda "return x;"
        - script.execute:
            id: refresh_display_iaq
            iaq_value: !lambda "return x;"
            is_weather: true
  - platform: homeassistant
    id: weather_humidity_ha
    entity_id: sensor.gw2000b_v2_2_4_humidity
    on_value:
      then:
        - globals.set:
            id: weather_humidity
            value: !lambda "return x;"
        - lambda: |-
            id(nextionWeatherHum).set_state(roundf(x * 10), false, true);
            id(nextionRoom7Hum).set_state(roundf(x * 10), false, true);
  - platform: homeassistant
    id: weather_temperature_ha
    entity_id: sensor.gw2000b_v2_2_4_outdoor_temperature
    on_value:
      then:
        - globals.set:
            id: weather_temperature
            value: !lambda "return x;"
        - lambda: |-
            id(nextionWeatherTemp).set_state(roundf(x * 10), false, true);
            id(nextionRoom7Temp).set_state(roundf(x * 10), false, true);
  - platform: homeassistant
    id: weather_forecasted_high_ha
    entity_id: sensor.weather_forecasted_high
    on_value:
      then:
        - globals.set:
            id: weather_temperature_high
            value: !lambda "return x;"
        - lambda: |-
            id(nextionWeatherTempHigh).set_state(roundf(x * 10), false, true);
  - platform: homeassistant
    id: weather_forecasted_low_ha
    entity_id: sensor.weather_forecasted_low
    on_value:
      then:
        - globals.set:
            id: weather_temperature_low
            value: !lambda "return x;"
        - lambda: |-
            id(nextionWeatherTempLow).set_state(roundf(x * 10), false, true);
  # Phototransistor ADC sensor
  - platform: adc
    id: adc_sensor_phototransistor
    name: Phototransistor ADC
    pin: 32
    attenuation: 11db
    update_interval: 1s
    filters:
      - sliding_window_moving_average:
          window_size: 5
          send_every: 3
          send_first_at: 1
    on_value:
      then:
        - lambda: |-
            if (id(esp_thermostat_display).state) {
              auto brightness_mult_max = 100.0;
              auto brightness_mult_min = 100.0 - id(esp_thermostat_display_brightness_idle_reduction).state;
              auto brightness_max = clamp<float>(roundf(id(adc_sensor_phototransistor).state / 3.9 * brightness_mult_max), id(esp_thermostat_display_minimum_brightness).state, id(esp_thermostat_display_maximum_brightness).state);
              auto brightness_min = clamp<float>(roundf(id(adc_sensor_phototransistor).state / 3.9 * brightness_mult_min), id(esp_thermostat_display_minimum_brightness).state, id(esp_thermostat_display_maximum_brightness).state);
              // ESP_LOGD("display_brightness", "Max: %f - Min: %f", brightness_max, brightness_min);
              id(nextionMaxBrightness).set_state(brightness_max, true, true);
              id(nextionMinBrightness).set_state(brightness_min, true, true);
            } else {
              id(nextionMaxBrightness).set_state(0, true, true);
              id(nextionMinBrightness).set_state(0, true, true);
            }
  # NTC thermistor ADC sensor
  - platform: adc
    id: adc_sensor_thermistor
    name: Thermistor ADC
    pin: 34
    internal: true
    update_interval: 1s
  # NTC thermistor resistance sensor
  - platform: resistance
    id: thermistor_sensor
    name: NTC Thermistor Resistance
    sensor: adc_sensor_thermistor
    configuration: DOWNSTREAM
    reference_voltage: ${ntc_reference_voltage}
    resistor: 10kOhm
    internal: true
  # NTC thermistor sensor
  - platform: ntc
    id: esp_thermostat_thermistor_temperature
    name: NTC Thermistor Temperature
    sensor: thermistor_sensor
    calibration:
      b_constant: 3380
      reference_temperature: 25°C
      reference_resistance: 10kOhm
    filters:
      - offset: ${ntc_temperature_offset}
      - sliding_window_moving_average:
          window_size: 60
          send_every: 15
          send_first_at: 15
    on_value:
      then:
        - lambda: |-
            auto temperature_string = str_sprintf("%.1f", celsius_to_fahrenheit(id(esp_thermostat_thermistor_temperature).state)) + "\xB0";
            id(nextionTextSensor6a).set_state(temperature_string, false, true);
  # DHT22 sensor
  # - platform: dht
  #   pin: 23
  #   model: DHT22
  #   temperature:
  #     id: esp_thermostat_dht22_temperature
  #     name: DHT22 Temperature
  #     filters:
  #       - offset: ${dht22_temperature_offset}
  #     on_value:
  #       then:
  #         - lambda: |-
  #             auto temperature_string = str_sprintf("%.1f", celsius_to_fahrenheit(id(esp_thermostat_dht22_temperature).state)) + "\xB0";
  #             id(nextionTextSensor5a).set_state(temperature_string, false, true);
  #   humidity:
  #     id: esp_thermostat_dht22_humidity
  #     name: DHT22 Humidity
  #     on_value:
  #       then:
  #         - lambda: |-
  #             auto humidity_string = str_sprintf("%.1f", id(esp_thermostat_dht22_humidity).state) + "%";
  #             id(nextionTextSensor5b).set_state(humidity_string, false, true);
  #   update_interval: 15s
  # BME280 sensor
  - platform: bme280_i2c
    address: 0x76
    temperature:
      id: esp_thermostat_bme280_temperature
      name: BME280 Temperature
      filters:
        - offset: ${bme280_temperature_offset}
      on_value:
        then:
          - lambda: |-
              auto temperature_string = str_sprintf("%.1f", celsius_to_fahrenheit(id(esp_thermostat_bme280_temperature).state)) + "\xB0";
              id(nextionTextSensor2a).set_state(temperature_string, false, true);
    humidity:
      id: esp_thermostat_bme280_humidity
      name: BME280 Humidity
      on_value:
        then:
          - lambda: |-
              auto humidity_string = str_sprintf("%.1f", id(esp_thermostat_bme280_humidity).state) + "%";
              id(nextionTextSensor2b).set_state(humidity_string, false, true);
    pressure:
      id: esp_thermostat_bme280_pressure
      name: BME280 Pressure
      on_value:
        then:
          - lambda: |-
              auto pressure_string = str_sprintf("%.1f", id(esp_thermostat_bme280_pressure).state) + "hPa";
              id(nextionTextSensor2c).set_state(pressure_string, false, true);
    update_interval: 15s
  # BME680 BSEC sensor
  - platform: bme680_bsec
    temperature:
      id: esp_thermostat_bme680_temperature
      name: BME680 Temperature
      filters:
        - offset: ${bme680_temperature_offset}
      on_value:
        then:
          - lambda: |-
              id(nextionRoom1Temp).set_state(roundf((celsius_to_fahrenheit(id(esp_thermostat_bme680_temperature).state)) * 10), false, true);
              auto temperature_string = str_sprintf("%.1f", celsius_to_fahrenheit(id(esp_thermostat_bme680_temperature).state)) + "\xB0";
              id(nextionTextSensor1a).set_state(temperature_string, false, true);
    humidity:
      id: esp_thermostat_bme680_humidity
      name: BME680 Humidity
      on_value:
        then:
          - lambda: |-
              id(nextionRoom1Hum).set_state(roundf(id(esp_thermostat_bme680_humidity).state * 10), false, true);
              auto humidity_string = str_sprintf("%.1f", id(esp_thermostat_bme680_humidity).state) + "%";
              id(nextionTextSensor1b).set_state(humidity_string, false, true);
    pressure:
      id: esp_thermostat_bme680_pressure
      name: BME680 Pressure
      on_value:
        then:
          - lambda: |-
              id(nextionCurrentPres).set_state(roundf(id(esp_thermostat_bme680_pressure).state * 10), false, true);
              auto pressure_string = str_sprintf("%.1f", id(esp_thermostat_bme680_pressure).state) + "hPa";
              id(nextionTextSensor1c).set_state(pressure_string, false, true);
    gas_resistance:
      id: esp_thermostat_bme680_gas_resistance
      name: BME680 Gas Resistance
      # on_value:
      #   then:
      #     - lambda: |-
      #         auto gas_res_string = str_sprintf("%.1f", id(esp_thermostat_bme680_gas_resistance).state);
      #         id(nextionTextSensor1d).set_state(gas_res_string, false, true);
    iaq:
      id: esp_thermostat_bme680_iaq
      name: BME680 IAQ
      on_value:
        then:
          - script.execute:
              id: refresh_display_iaq
              iaq_value: !lambda "return id(esp_thermostat_bme680_iaq).state;"
              is_weather: false
          - lambda: |-
              auto iaq_string = str_sprintf("%.1f", id(esp_thermostat_bme680_iaq).state);
              id(nextionTextSensor1d).set_state(iaq_string, false, true);
    co2_equivalent:
      id: esp_thermostat_bme680_eco2
      name: BME680 eCO2
    breath_voc_equivalent:
      id: esp_thermostat_bme680_evoc
      name: BME680 Breath eVOC
  # BME680 sensor
  # - platform: bme680
  #   address: 0x77
  #   temperature:
  #     id: esp_thermostat_bme680_temperature
  #     name: BME680 Temperature
  #     filters:
  #       - offset: -1.2
  #     on_value:
  #       then:
  #         - lambda: |-
  #             auto temperature_string = str_sprintf("%.1f", celsius_to_fahrenheit(id(esp_thermostat_bme680_temperature).state)) + "\xB0";
  #             id(nextionTextSensor1a).set_state(temperature_string, false, true);
  #             esp32_thermostat::display_refresh_table_temperature(id(climate_table_local_row), id(esp_thermostat_bme680_temperature).state);
  #   humidity:
  #     id: esp_thermostat_bme680_humidity
  #     name: BME680 Humidity
  #     on_value:
  #       then:
  #         - lambda: |-
  #             auto humidity_string = str_sprintf("%.1f", id(esp_thermostat_bme680_humidity).state) + "%";
  #             id(nextionTextSensor1b).set_state(humidity_string, false, true);
  #             esp32_thermostat::display_refresh_table_humidity(id(climate_table_local_row), id(esp_thermostat_bme680_humidity).state);
  #   pressure:
  #     id: esp_thermostat_bme680_pressure
  #     name: BME680 Pressure
  #     on_value:
  #       then:
  #         - lambda: |-
  #             auto pressure_string = str_sprintf("%.1f", id(esp_thermostat_bme680_pressure).state) + "hPa";
  #             id(nextionTextSensor1c).set_state(pressure_string, false, true);
  #   gas_resistance:
  #     id: esp_thermostat_bme680_gas_resistance
  #     name: BME680 Gas Resistance
  #     on_value:
  #       then:
  #         - lambda: |-
  #             auto gas_res_string = str_sprintf("%.1f", id(esp_thermostat_bme680_gas_resistance).state);
  #             id(nextionTextSensor1d).set_state(gas_res_string, false, true);
  #   update_interval: 15s
  # SHTC3 sensor
  - platform: shtcx
    temperature:
      id: esp_thermostat_shtcx_temperature
      name: SHTC3 Temperature
      filters:
        - offset: ${shtc3_temperature_offset}
      on_value:
        then:
          - lambda: |-
              auto temperature_string = str_sprintf("%.1f", celsius_to_fahrenheit(id(esp_thermostat_shtcx_temperature).state)) + "\xB0";
              id(nextionTextSensor3a).set_state(temperature_string, false, true);
    humidity:
      id: esp_thermostat_shtcx_humidity
      name: SHTC3 Humidity
      on_value:
        then:
          - lambda: |-
              auto humidity_string = str_sprintf("%.1f", id(esp_thermostat_shtcx_humidity).state) + "%";
              id(nextionTextSensor3b).set_state(humidity_string, false, true);
    update_interval: 15s
  # TMP117 sensor
  - platform: tmp117
    id: esp_thermostat_tmp117_temperature
    name: TMP117 Temperature
    filters:
      - offset: ${tmp117_temperature_offset}
    on_value:
      then:
        - lambda: |-
            auto temperature_string = str_sprintf("%.1f", celsius_to_fahrenheit(id(esp_thermostat_tmp117_temperature).state)) + "\xB0";
            id(nextionTextSensor4a).set_state(temperature_string, false, true);
    update_interval: 15s
  # SGP40 sensor
  - platform: sgp4x
    voc:
      id: esp_thermostat_sgp40_voc
      name: SGP40 VOC
      unit_of_measurement: VOC Index
      on_value:
        then:
          - lambda: |-
              auto voc_string = str_sprintf("%.1f", id(esp_thermostat_sgp40_voc).state);
              id(nextionTextSensor8d).set_state(voc_string, false, true);
    update_interval: 15s
    compensation:
      humidity_source: esp_thermostat_shtcx_humidity
      temperature_source: esp_thermostat_shtcx_temperature
  # Nextion climate state (action/mode/fan_mode) sensors
  - platform: nextion
    nextion_id: main_lcd
    id: nextionClimateAction
    variable_name: climateAction
  - platform: nextion
    nextion_id: main_lcd
    id: nextionClimateMode
    variable_name: climateMode
    on_value:
      then:
        - climate.control:
            id: esp_thermostat
            mode: !lambda "return static_cast<climate::ClimateMode>(int(id(nextionClimateMode).state));"
  - platform: nextion
    nextion_id: main_lcd
    id: nextionClimateFanMode
    variable_name: climateFanMode
    on_value:
      then:
        - climate.control:
            id: esp_thermostat
            fan_mode: !lambda |-
              // we could allow any fan mode like this...
              // return static_cast<climate::ClimateFanMode>(int(id(nextionClimateFanMode).state));"
              // ...instead we'll only allow ON or AUTO modes this way:
              if (static_cast<climate::ClimateFanMode>(int(id(nextionClimateFanMode).state)) == CLIMATE_FAN_ON) {
                return CLIMATE_FAN_ON;
              }
              return CLIMATE_FAN_AUTO;
  # Other Nextion sensors
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTargetBrightness
    variable_name: targetBrightness
  - platform: nextion
    nextion_id: main_lcd
    id: nextionMaxBrightness
    variable_name: maxBrightness
  - platform: nextion
    nextion_id: main_lcd
    id: nextionMinBrightness
    variable_name: minBrightness
  - platform: nextion
    nextion_id: main_lcd
    id: nextionIdleTimeout
    variable_name: idleTimeout
  - platform: nextion
    nextion_id: main_lcd
    id: nextionIdleTimer
    variable_name: idleTimer
  - platform: nextion
    nextion_id: main_lcd
    id: nextionAutoBrightness
    variable_name: autoBrightness
  - platform: nextion
    nextion_id: main_lcd
    id: nextionAutoHome
    variable_name: autoHome
  - platform: nextion
    nextion_id: main_lcd
    id: nextionCurrentTemp
    variable_name: currentTemp
  - platform: nextion
    nextion_id: main_lcd
    id: nextionCurrentTempHigh
    variable_name: currentTempHigh
  - platform: nextion
    nextion_id: main_lcd
    id: nextionCurrentTempLow
    variable_name: currentTempLow
  - platform: nextion
    nextion_id: main_lcd
    id: nextionCurrentHum
    variable_name: currentHum
  - platform: nextion
    nextion_id: main_lcd
    id: nextionCurrentPres
    variable_name: currentPres
  - platform: nextion
    nextion_id: main_lcd
    id: nextionCurrentSetHum
    variable_name: currentSetHum
  - platform: nextion
    nextion_id: main_lcd
    id: nextionCurrentSetLower
    variable_name: currentSetLower
    on_value:
      then:
        - climate.control:
            id: esp_thermostat
            target_temperature_low: !lambda "return fahrenheit_to_celsius(id(nextionCurrentSetLower).state / 10);"
        - lambda: |-
            if (id(nextionCurrentSetLower).state != (celsius_to_fahrenheit(id(esp_thermostat).target_temperature_low)) * 10)
              id(nextionCurrentSetLower).set_state(celsius_to_fahrenheit(id(esp_thermostat).target_temperature_low) * 10, false, true);
  - platform: nextion
    nextion_id: main_lcd
    id: nextionCurrentSetUpper
    variable_name: currentSetUpper
    on_value:
      then:
        - climate.control:
            id: esp_thermostat
            target_temperature_high: !lambda "return fahrenheit_to_celsius(id(nextionCurrentSetUpper).state / 10);"
        - lambda: |-
            if (id(nextionCurrentSetUpper).state != (celsius_to_fahrenheit(id(esp_thermostat).target_temperature_high)) * 10)
              id(nextionCurrentSetUpper).set_state(celsius_to_fahrenheit(id(esp_thermostat).target_temperature_high) * 10, false, true);
  - platform: nextion
    nextion_id: main_lcd
    id: nextionCurrentSetMin
    variable_name: currentSetMin
  - platform: nextion
    nextion_id: main_lcd
    id: nextionCurrentSetMax
    variable_name: currentSetMax
  - platform: nextion
    nextion_id: main_lcd
    id: nextionWeatherTemp
    variable_name: weatherTemp
  - platform: nextion
    nextion_id: main_lcd
    id: nextionWeatherHum
    variable_name: weatherHum
  - platform: nextion
    nextion_id: main_lcd
    id: nextionWeatherTempHigh
    variable_name: weatherTempHigh
  - platform: nextion
    nextion_id: main_lcd
    id: nextionWeatherTempLow
    variable_name: weatherTempLow
  - platform: nextion
    nextion_id: main_lcd
    id: nextionWeatherCondIcon
    variable_name: weatherCondIcon
  - platform: nextion
    nextion_id: main_lcd
    id: nextionLockoutState
    variable_name: lockoutState
  - platform: nextion
    nextion_id: main_lcd
    id: nextionRoom1Temp
    variable_name: room1Temp
  - platform: nextion
    nextion_id: main_lcd
    id: nextionRoom1Hum
    variable_name: room1Hum
  - platform: nextion
    nextion_id: main_lcd
    id: nextionRoom2Temp
    variable_name: room2Temp
  - platform: nextion
    nextion_id: main_lcd
    id: nextionRoom2Hum
    variable_name: room2Hum
  - platform: nextion
    nextion_id: main_lcd
    id: nextionRoom3Temp
    variable_name: room3Temp
  - platform: nextion
    nextion_id: main_lcd
    id: nextionRoom3Hum
    variable_name: room3Hum
  - platform: nextion
    nextion_id: main_lcd
    id: nextionRoom4Temp
    variable_name: room4Temp
  - platform: nextion
    nextion_id: main_lcd
    id: nextionRoom4Hum
    variable_name: room4Hum
  - platform: nextion
    nextion_id: main_lcd
    id: nextionRoom5Temp
    variable_name: room5Temp
  - platform: nextion
    nextion_id: main_lcd
    id: nextionRoom5Hum
    variable_name: room5Hum
  - platform: nextion
    nextion_id: main_lcd
    id: nextionRoom6Temp
    variable_name: room6Temp
  - platform: nextion
    nextion_id: main_lcd
    id: nextionRoom6Hum
    variable_name: room6Hum
  - platform: nextion
    nextion_id: main_lcd
    id: nextionRoom7Temp
    variable_name: room7Temp
  - platform: nextion
    nextion_id: main_lcd
    id: nextionRoom7Hum
    variable_name: room7Hum
  - platform: nextion
    nextion_id: main_lcd
    id: nextionRoom8Temp
    variable_name: room8Temp
  - platform: nextion
    nextion_id: main_lcd
    id: nextionRoom8Hum
    variable_name: room8Hum

text_sensor:
  - platform: bme680_bsec
    iaq_accuracy:
      id: esp_thermostat_bme680_accuracy
      name: BME680 Accuracy
  # HA sensors we track - weather condition
  - platform: homeassistant
    id: weather_condition_ha
    entity_id: ${weather_entity}
    on_value:
      then:
        - globals.set:
            id: weather_condition
            value: !lambda "return x;"
        - script.execute: refresh_display_weather_condition
  # Nextion text sensors
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextStatus
    component_name: ${home_page_name}.txtStatus
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextCurrentAq
    component_name: ${home_page_name}.txtCurrentAq
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextWeatherAq
    component_name: ${weather_page_name}.txtWeatherAq
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextWeatherIcon
    component_name: ${weather_page_name}.txtWeatherIcon
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextRoom1
    component_name: ${rooms_page_name}.txtRoom1
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextRoom2
    component_name: ${rooms_page_name}.txtRoom2
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextRoom3
    component_name: ${rooms_page_name}.txtRoom3
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextRoom4
    component_name: ${rooms_page_name}.txtRoom4
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextRoom5
    component_name: ${rooms_page_name}.txtRoom5
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextRoom6
    component_name: ${rooms_page_name}.txtRoom6
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextRoom7
    component_name: ${rooms_page_name}.txtRoom7
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextRoom8
    component_name: ${rooms_page_name}.txtRoom8
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor1
    component_name: ${sensors_page_name}.txtSensor1
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor2
    component_name: ${sensors_page_name}.txtSensor2
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor3
    component_name: ${sensors_page_name}.txtSensor3
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor4
    component_name: ${sensors_page_name}.txtSensor4
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor5
    component_name: ${sensors_page_name}.txtSensor5
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor6
    component_name: ${sensors_page_name}.txtSensor6
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor7
    component_name: ${sensors_page_name}.txtSensor7
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor8
    component_name: ${sensors_page_name}.txtSensor8
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor1a
    component_name: ${sensors_page_name}.txtSensor1a
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor2a
    component_name: ${sensors_page_name}.txtSensor2a
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor3a
    component_name: ${sensors_page_name}.txtSensor3a
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor4a
    component_name: ${sensors_page_name}.txtSensor4a
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor5a
    component_name: ${sensors_page_name}.txtSensor5a
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor6a
    component_name: ${sensors_page_name}.txtSensor6a
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor7a
    component_name: ${sensors_page_name}.txtSensor7a
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor8a
    component_name: ${sensors_page_name}.txtSensor8a
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor1b
    component_name: ${sensors_page_name}.txtSensor1b
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor2b
    component_name: ${sensors_page_name}.txtSensor2b
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor3b
    component_name: ${sensors_page_name}.txtSensor3b
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor4b
    component_name: ${sensors_page_name}.txtSensor4b
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor5b
    component_name: ${sensors_page_name}.txtSensor5b
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor6b
    component_name: ${sensors_page_name}.txtSensor6b
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor7b
    component_name: ${sensors_page_name}.txtSensor7b
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor8b
    component_name: ${sensors_page_name}.txtSensor8b
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor1c
    component_name: ${sensors_page_name}.txtSensor1c
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor2c
    component_name: ${sensors_page_name}.txtSensor2c
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor3c
    component_name: ${sensors_page_name}.txtSensor3c
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor4c
    component_name: ${sensors_page_name}.txtSensor4c
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor5c
    component_name: ${sensors_page_name}.txtSensor5c
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor6c
    component_name: ${sensors_page_name}.txtSensor6c
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor7c
    component_name: ${sensors_page_name}.txtSensor7c
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor8c
    component_name: ${sensors_page_name}.txtSensor8c
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor1d
    component_name: ${sensors_page_name}.txtSensor1d
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor2d
    component_name: ${sensors_page_name}.txtSensor2d
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor3d
    component_name: ${sensors_page_name}.txtSensor3d
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor4d
    component_name: ${sensors_page_name}.txtSensor4d
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor5d
    component_name: ${sensors_page_name}.txtSensor5d
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor6d
    component_name: ${sensors_page_name}.txtSensor6d
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor7d
    component_name: ${sensors_page_name}.txtSensor7d
  - platform: nextion
    nextion_id: main_lcd
    id: nextionTextSensor8d
    component_name: ${sensors_page_name}.txtSensor8d

switch:
  # display power (hard/physical)
  - platform: gpio
    id: esp_thermostat_display_power
    name: Display Power
    entity_category: config
    restore_mode: ALWAYS_ON
    pin:
      number: 25
      mode: OUTPUT
  # automatic display brightness control
  - platform: template
    id: esp_thermostat_display_auto_brightness
    name: Display Automatic Brightness
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    on_turn_off:
      then:
        lambda: |-
          id(nextionAutoBrightness).set_state(0, true, true);
    on_turn_on:
      then:
        lambda: |-
          id(nextionAutoBrightness).set_state(1, true, true);
  # display power (soft)
  - platform: template
    id: esp_thermostat_display
    name: Display
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
  # display brightness control by motion
  - platform: template
    id: esp_thermostat_display_on_motion
    name: Display On Motion
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

number:
  - platform: template
    id: esp_thermostat_target_humidity
    name: Target Humidity
    optimistic: true
    mode: box
    min_value: 0
    max_value: 100
    step: 0.1
    initial_value: 30
    restore_value: true
    unit_of_measurement: "%"
    on_value:
      then:
        lambda: "id(nextionCurrentSetHum).set_state(id(esp_thermostat_target_humidity).state * 10, false, true);"
  # for determining sensor weights when used as a part of climate control system average
  - platform: template
    id: esp_thermostat_humidity_weight
    name: Humidity Weight
    entity_category: config
    optimistic: true
    min_value: 0
    max_value: 10
    step: 1
    initial_value: 5
    restore_value: true
  - platform: template
    id: esp_thermostat_temperature_weight
    name: Temperature Weight
    entity_category: config
    optimistic: true
    min_value: 0
    max_value: 10
    step: 1
    initial_value: 5
    restore_value: true
  # display brightness controls
  - platform: template
    id: esp_thermostat_display_brightness
    name: Display Brightness
    entity_category: config
    mode: box
    min_value: 0
    max_value: 100
    step: 1
    lambda: "return id(nextionTargetBrightness).state;"
    unit_of_measurement: "%"
    update_interval: 1s
    set_action:
      then:
        lambda: |-
          if (id(nextionTargetBrightness).state != x)
            id(nextionTargetBrightness).set_state(x, true, true);
  - platform: template
    id: esp_thermostat_display_minimum_brightness
    name: Display Minimum Brightness
    entity_category: config
    mode: box
    optimistic: true
    unit_of_measurement: "%"
    min_value: 0
    max_value: 99
    step: 1
    initial_value: 5
    restore_value: true
  - platform: template
    id: esp_thermostat_display_maximum_brightness
    name: Display Maximum Brightness
    entity_category: config
    mode: box
    optimistic: true
    unit_of_measurement: "%"
    min_value: 1
    max_value: 100
    step: 1
    initial_value: 100
    restore_value: true
  - platform: template
    id: esp_thermostat_display_brightness_idle_reduction
    name: Display Brightness Idle Reduction
    entity_category: config
    mode: box
    optimistic: true
    unit_of_measurement: "%"
    min_value: 0
    max_value: 100
    step: 1
    initial_value: 80
    restore_value: true
  - platform: template
    id: esp_thermostat_idle_timeout
    name: Idle Timeout
    entity_category: config
    mode: box
    optimistic: true
    unit_of_measurement: s
    min_value: 5
    max_value: 900
    step: 1
    initial_value: 120
    restore_value: true
    on_value:
      then:
        lambda: "id(nextionIdleTimeout).set_state(x * 2, true, true);"